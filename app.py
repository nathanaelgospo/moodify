from flask import Flask, request, session, redirect, render_template, url_for
from openai import OpenAI
import spotipy
import time
import os
import random
import json


from dotenv import load_dotenv
print("lo")
from spotipy.oauth2 import SpotifyClientCredentials
from spotipy.oauth2 import SpotifyOAuth


app = Flask(__name__)

load_dotenv()
app.secret_key = os.getenv("SECRET_KEY")
app.config['SESSION_COOKIE_NAME'] = 'lard.html'

AIkey = os.getenv("OPENAI_KEY")
clientID = os.getenv("CLIENT_ID")
clientSecret = os.getenv("CLIENT_SECRET")
TOKEN_INFO = "token_info"

@app.route('/login')
def login():
    sp_oauth = create_spotify_oauth()
    auth_url = sp_oauth.get_authorize_url()
    return redirect(auth_url)

def create_spotify_oauth():
    return SpotifyOAuth(client_id = clientID, client_secret = clientSecret, redirect_uri=url_for('redirectPage', _external=True), scope="playlist-modify-public playlist-modify-private user-library-read user-read-private")

@app.route('/')
def index():
    return render_template("index.html")

@app.route('/redirect')
def redirectPage():
    sp_oauth = create_spotify_oauth()
    session.clear()
    code = request.args.get('code')
    token_info = sp_oauth.get_access_token(code)
    session[TOKEN_INFO] = token_info
    return redirect(url_for('index', _external=True))



def getRandomTracks():
    try:
        token_info = get_token()
    except:
        print("User not logged in")
        return redirect(url_for("login", _external=False))
    
    sp = spotipy.Spotify(auth=token_info['access_token'])
    
    # Get the saved tracks for the current user, with pagination
    iter = 0
    all_tracks = []  # Initialize an empty list to store tracks
    
    while True:
        results = sp.current_user_saved_tracks(limit=50, offset=iter * 50)
        tracks = results['items']
        
        if not tracks:
            break  # No more tracks to fetch, exit the loop
        
        # Add the tracks to the list
        all_tracks.extend(tracks)
        
        iter += 1  # Move to the next page of tracks
    
    # Shuffle the tracks to get random order
    random.shuffle(all_tracks)
    
    # Get the first 50 random tracks
    random_tracks = all_tracks[:50]
    
    # Create a dictionary with song names and artists
    track_dict = {}
    for item in random_tracks:
        track = item['track']
        song_name = track['name']
        artists = [artist['name'] for artist in track['artists']]
        track_dict[song_name] = artists
    
    return track_dict

def get_token():
    token_info = session.get(TOKEN_INFO, None)
    if not token_info:
        raise ValueError("No token found in session.")  # Raise a clear exception

    now = int(time.time())
    is_expired = token_info['expires_at'] - now < 60
    if is_expired:
        # Token is expired, refresh it
        sp_oauth = create_spotify_oauth()
        token_info = sp_oauth.refresh_access_token(token_info)

    return token_info

@app.route('/result', methods=["POST", "GET"])
def createPlaylist():
    if request.method == "POST":
          # Get the response and clean it up
        user_data = request.form.get("data")
        songDict = getRandomTracks()
        print(str(songDict))
        playlistData = processData(user_data, songDict)
        print(str(playlistData))
        playlistName = playlistData["playListName"]
        del playlistData["playListName"]

        playlist = []  # Use a list to store the song-artist entries
        for item in playlistData["Songs"]:
            if "-" in item:  # Ensure that we only process valid entries with song and artist
                song_artist = item.split('-',1)
                song = song_artist[0].strip()  # Get the song name, strip extra spaces
                artist = song_artist[1].strip()  # Get the artist name, strip extra spaces

                playlist.append({"song": song, "artist": artist})
            
        for item in playlist:
            print(f" Value: {item}")

        sp = spotipy.Spotify(auth_manager=create_spotify_oauth())
        user_id = sp.current_user()['id']
        playlist_id = create_spotify_playlist(user_id, playlistName, True, False, "Generated by moodify")
        add_tracks_to_playlist(user_id, playlist_id, playlist)
        return render_template('result.html', playlistID = playlist_id)


def add_tracks_to_playlist(userId,playlist_id, tracks):
    sp = spotipy.Spotify(auth_manager=create_spotify_oauth())
    track_uris = []
    for track in tracks:
        query = f"{track['song']} {track['artist']}"  # Format search query
        print(f"Searching for: {query}")

        try:
            results = sp.search(q=query, limit=1, type='track')
            if results['tracks']['items']:
                track_uri = results['tracks']['items'][0]['uri']
                track_uris.append(track_uri)
            else:
                print(f"Track not found: {query}")  # Log missing tracks
        except spotipy.exceptions.SpotifyException as e:
            print(f"Spotify API error: {e}")
            time.sleep(2)  # Small delay in case of rate limits

    if track_uris:
        try:
            sp.playlist_add_items(playlist_id, track_uris)
            print(f"Added {len(track_uris)} tracks to the playlist!")
        except spotipy.exceptions.SpotifyException as e:
            print(f"Error adding tracks: {e}")




def create_spotify_playlist(user_id, playlist_name, isPublic, isCollaborative, playlist_description):
    sp = spotipy.Spotify(auth_manager=create_spotify_oauth())
    playlist = sp.user_playlist_create(user_id, playlist_name, isPublic, isCollaborative, playlist_description)
    return playlist['id']  




    

    
#process the data with chat-gpt and creates a playlist JSON file
def processData(userData, songs):
    client = OpenAI(api_key=AIkey)
    completion = client.chat.completions.create(
        model="gpt-4-turbo",
        messages=[
            {"role": "user", "content": f"User is experiencing: {userData}. Generate a playlist using only the following format (DO NOT ADD NUMBERS IN FRONT OF THE SONG. THERE SHOULD ONLY BE A - BETWEEN THE SONG AND THE ARTIST):\n\nPlaylist Name: [Generated Playlist Name]\n\nSong - Artist\nSong - Artist\n3. Song - Artist\n...\n Song - Artist"}
        ])

    feedback = completion.choices[0].message.content.strip()

    # Split the response by newlines and then further split each line by '-'
    feedback_list = feedback.split('\n')


    completion2 = client.chat.completions.create(
        model="gpt-4-turbo",
        messages=[
            {"role": "system", "content": "Give me a name for the playlist that you just created and make it fitting off of the {userData} don't include parenthesis!!!! KEEP THE NAME SHORT"}])

    # Get the playlist name and strip extra spaces
    playListName = completion2.choices[0].message.content.strip()

    # Create a list of dictionaries for each song and artist
    songs = [entry.strip() for entry in feedback_list[1:]]

    playListDict = {
        "playListName": playListName,
        "Songs": songs
    }
    
    return playListDict
        

#OpenAi stuff


if __name__ == '__main__':
    app.run(debug=True)