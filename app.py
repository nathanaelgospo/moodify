from flask import Flask, request, url_for, session, redirect, render_template
from openai import OpenAI
import spotipy
import time
import os
import random
import json


from dotenv import load_dotenv
from spotipy.oauth2 import SpotifyClientCredentials
from spotipy.oauth2 import SpotifyOAuth


app = Flask(__name__)

load_dotenv()
app.secret_key = os.getenv("SECRET_KEY")
app.config['SESSION_COOKIE_NAME'] = 'lard.html'

key = os.getenv("OPENAI_KEY")
clientID = os.getenv("CLIENT_ID")
clientSecret = os.getenv("CLIENT_SECRET")
TOKEN_INFO = "token_info"

@app.route('/login')
def login():
    sp_oauth = create_spotify_oauth()
    auth_url = sp_oauth.get_authorize_url()
    return redirect(auth_url)

def create_spotify_oauth():
    return SpotifyOAuth(client_id = clientID, client_secret = clientSecret, redirect_uri=url_for('redirectPage', _external=True), scope="playlist-modify-public playlist-modify-private user-library-read user-read-private")

@app.route('/')
def index():
    return render_template("index.html")

@app.route('/redirect')
def redirectPage():
    sp_oauth = create_spotify_oauth()
    session.clear()
    code = request.args.get('code')
    token_info = sp_oauth.get_access_token(code)
    session[TOKEN_INFO] = token_info
    return redirect(url_for('index', _external=True))



def getRandomTracks():
    try:
        token_info = get_token()
    except:
        print("User not logged in")
        return redirect(url_for("login", _external=False))
    
    sp = spotipy.Spotify(auth=token_info['access_token'])
    
    # Get the saved tracks for the current user, with pagination
    iter = 0
    all_tracks = []  # Initialize an empty list to store tracks
    
    while True:
        results = sp.current_user_saved_tracks(limit=50, offset=iter * 50)
        tracks = results['items']
        
        if not tracks:
            break  # No more tracks to fetch, exit the loop
        
        # Add the tracks to the list
        all_tracks.extend(tracks)
        
        iter += 1  # Move to the next page of tracks
    
    # Shuffle the tracks to get random order
    random.shuffle(all_tracks)
    
    # Get the first 50 random tracks
    random_tracks = all_tracks[:50]
    
    # Create a dictionary with song names and artists
    track_dict = {}
    for item in random_tracks:
        track = item['track']
        song_name = track['name']
        artists = [artist['name'] for artist in track['artists']]
        track_dict[song_name] = artists
    
    return track_dict

def get_token():
    token_info = session.get(TOKEN_INFO, None)
    if not token_info:
        raise ValueError("No token found in session.")  # Raise a clear exception

    now = int(time.time())
    is_expired = token_info['expires_at'] - now < 60
    if is_expired:
        # Token is expired, refresh it
        sp_oauth = create_spotify_oauth()
        token_info = sp_oauth.refresh_access_token(token_info['refresh_token'])

    return token_info

@app.route('/output', methods=["POST", "GET"])
def createPlaylist():
    if request.method == "POST":
          # Get the response and clean it up
        user_data = request.form.get("data")
        songDict = getRandomTracks
        print(str(songDict))
        playlistData = processData(user_data, songDict)
        print(str(playlistData))
        playlistName = playlistData["playListName"]
        del playlistData["playListName"]

        playlist = []  # Use a list to store the song-artist entries
        for item in playlistData:
            if "-" in item:  # Ensure that we only process valid entries with song and artist
                song_artist = item.split('-')
                song = song_artist[0].strip()  # Get the song name, strip extra spaces
                print(str(song))
                artist = song_artist[1].strip()  # Get the artist name, strip extra spaces
                print(str(artist))

                playlist.append({"song": song, "artist": artist})
            
        
        sp = spotipy.Spotify(auth_manager=create_spotify_oauth())
        user_id = sp.current_user()['id']
        playlist_id = create_spotify_playlist(user_id, playlistName, True, False, "Generated by moodify")
        add_tracks_to_playlist(user_id, playlist_id, playlist)
        return "Playlist Created Successfully!"


def add_tracks_to_playlist(userId,playlist_id, tracks):
    sp = spotipy.Spotify(auth_manager=create_spotify_oauth())
    track_uris = []
    for track in tracks:
        query = track['song'] + " " + track['artist']  # Combine song and artist for search query
        print(str(query))
        results = sp.search(q=query, limit=1, type='track')
        if results['tracks']['items']:
            track_uris.append(results['tracks']['items'][0]['uri'])  # Collect track URI

        if track_uris:
            sp.user_playlist_add_tracks(userId, playlist_id, track_uris, None)  # Add tracks to playlist





def create_spotify_playlist(user_id, playlist_name, isPublic, isCollaborative, playlist_description):
    sp = spotipy.Spotify(auth_manager=create_spotify_oauth())
    playlist = sp.user_playlist_create(user_id, playlist_name, isPublic, isCollaborative, playlist_description)
    return playlist['id']  




    

    
#process the data with chat-gpt and creates a playlist JSON file
def processData(userData, songs):
    client = OpenAI(api_key=key)
    completion = client.chat.completions.create(
        model="gpt-4-turbo",
        messages=[
            {"role": "system", "content": "You create song playlists based on a user's life situation. Given the user's current circumstances, generate a 25-song playlist that fits their mood or experience. Here are 50 random songs that the user likes {songs}"},{"role": "user", "content": f"User is experiencing: {userData}. Generate a 25-song playlist in the format 'song - artist', one entry per line."}])

    feedback = completion.choices[0].message.content.strip()

    # Split the response by newlines and then further split each line by '-'
    feedback_list = feedback.split('\n')


    completion2 = client.chat.completions.create(
        model="gpt-4-turbo",
        messages=[
            {"role": "system", "content": "Give me a name for the playlist that you just created and make it fitting"}])

    # Get the playlist name and strip extra spaces
    playListName = completion2.choices[0].message.content.strip()

    # Create a list of dictionaries for each song and artist
    songs = [entry.strip() for entry in feedback_list[1:]]

    playListDict = {
        "playListName": playListName,
        "Songs": songs
    }

    return playListDict
        

#OpenAi stuff


if __name__ == '__main__':
    app.run(debug=True)